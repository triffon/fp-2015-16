λ> init $ [1..10]
[1,2,3,4,5,6,7,8,9]
λ> ($[1..10]) init
[1,2,3,4,5,6,7,8,9]
λ> ($[1..10]) tail
[2,3,4,5,6,7,8,9,10]
λ> ($[1..10]) (drop 3)
[4,5,6,7,8,9,10]
λ> ($[1..10]) last
10
λ> map ($2) [(^2),(1+),(*3)]
[4,3,6]
λ> [x^2 | x <- [1..10], isOdd x]

<interactive>:16:22-26: Not in scope: ‘isOdd’
λ> [x^2 | x <- [1..10], isEven x]

<interactive>:17:22-27: Not in scope: ‘isEven’
λ> [x^2 | x <- [1..10], odd x]
[1,9,25,49,81]
λ> map (\x -> x^2) (filter (\x -> odd x) [1..10])
[1,9,25,49,81]
λ> map (\x -> x^2) (filter odd [1..10])
[1,9,25,49,81]
λ> map (^2) (filter odd [1..10])
[1,9,25,49,81]
λ> [(x,y) | x <- [1..3], y <- [5..7]]
[(1,5),(1,6),(1,7),(2,5),(2,6),(2,7),(3,5),(3,6),(3,7)]
λ> map (\x -> map (\y -> (x,y)) [5..7]) [1..3]
[[(1,5),(1,6),(1,7)],[(2,5),(2,6),(2,7)],[(3,5),(3,6),(3,7)]]
λ> concat (map (\x -> map (\y -> (x,y)) [5..7]) [1..3])
[(1,5),(1,6),(1,7),(2,5),(2,6),(2,7),(3,5),(3,6),(3,7)]
λ> concatMap (\x -> map (\y -> (x,y)) [5..7]) [1..3]
[(1,5),(1,6),(1,7),(2,5),(2,6),(2,7),(3,5),(3,6),(3,7)]
λ> foldr (\x r -> x:r) [1..10]

<interactive>:27:1-27:
    No instance for (Show ([a0] -> [a0])) arising from a use of ‘print’
    In a stmt of an interactive GHCi command: print it
λ> foldr (\x r -> x:r) [] [1..10]
[1,2,3,4,5,6,7,8,9,10]
λ> foldr (\x r -> (:) x r) [] [1..10]
[1,2,3,4,5,6,7,8,9,10]
λ> foldr (\x -> (:) x) [] [1..10]
[1,2,3,4,5,6,7,8,9,10]
λ> foldr (:) [] [1..10]
[1,2,3,4,5,6,7,8,9,10]
λ> foldr (\x r -> x^2:r) [] [1..10]
[1,4,9,16,25,36,49,64,81,100]
λ> foldr (\x r -> odd x:r) [] [1..10]
[True,False,True,False,True,False,True,False,True,False]
λ> map (^2) [1..10]
[1,4,9,16,25,36,49,64,81,100]
λ> filter even [1..10]filter even [1..10]
[2,4,6,8,10]
λ> filter even [1..10]
[2,4,6,8,10]
λ> foldl (:) [] [1..10]

<interactive>:9:7-9:
    Occurs check: cannot construct the infinite type: t ~ [t]
    Expected type: [t] -> [[t]] -> [t]
      Actual type: [t] -> [[t]] -> [[t]]
    Relevant bindings include it :: [t] (bound at <interactive>:9:1)
    In the first argument of ‘foldl’, namely ‘(:)’
    In the expression: foldl (:) [] [1 .. 10]
λ> :t (:)
(:) :: a -> [a] -> [a]
λ> :t foldl
foldl :: (b -> a -> b) -> b -> [a] -> b
λ> :t (\t h -> h : t)
(\t h -> h : t) :: [a] -> a -> [a]
λ> foldl (\t h -> h:t) [] [1..10]
[10,9,8,7,6,5,4,3,2,1]
λ> foldl (flip (:)) [] [1..10]
[10,9,8,7,6,5,4,3,2,1]
λ> foldl (\t h -> (:) h t) [] [1..10]
[10,9,8,7,6,5,4,3,2,1]
λ> foldr (+) 0 [1..10]
55
λ> scanr (+) 0 [1..10]
[55,54,52,49,45,40,34,27,19,10,0]
λ> foldl (+) 0 [1..10]
55
λ> scanl (+) 0 [1..10]
[0,1,3,6,10,15,21,28,36,45,55]
λ> scanr (+) 0 [1..10]
[55,54,52,49,45,40,34,27,19,10,0]
λ> scanr (+) 0 [1..10]
[55,54,52,49,45,40,34,27,19,10,0,0]
λ> scanr (+) 0 [1..10]
[55,54,52,49,45,40,34,27,19,10,0]
λ> scanr (+) 0 [1..10]
[55,54,52,49,45,40,34,27,19,10,0,0,0]
λ> zip [1..5] [11..15]
[(1,11),(2,12),(3,13),(4,14),(5,15)]
λ> zip [1..5] [11..20]
[(1,11),(2,12),(3,13),(4,14),(5,15)]
λ> 